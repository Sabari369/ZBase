package Model;

public class Column {
	
	String name;        
	String dataType;
	boolean isNullable;
	Constraint constraint;
	
	public Column(String name, String dataType, boolean isNullable, Constraint constraint) {
		super();
		this.name = name;
		this.dataType = dataType;
		this.isNullable = isNullable;
		this.constraint = constraint;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDataType() {
		return dataType;
	}

	public void setDataType(String dataType) {
		this.dataType = dataType;
	}

	public boolean isNullable() {
		return isNullable;
	}

	public void setNullable(boolean isNullable) {
		this.isNullable = isNullable;
	}

	public Constraint getConstraint() {
		return constraint;
	}

	public void setConstraint(Constraint constraint) {
		this.constraint = constraint;
	}
}



package Model;

import java.io.Serializable;


public class Constraint implements Serializable {
    private String name;
    private String type; // e.g., PRIMARY KEY, FOREIGN KEY, UNIQUE, etc.
    private String columnName;
    private String referenceTable;  // For FOREIGN KEY constraints
    private String referenceColumn; // For FOREIGN KEY constraints

    // Constructor
    public Constraint(String name, String type, String columnName, String referenceTable, String referenceColumn) {
        this.name = name;
        this.type = type;
        this.columnName = columnName;
        this.referenceTable = referenceTable;
        this.referenceColumn = referenceColumn;
    }

    // Getters and Setters
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getColumnName() {
        return columnName;
    }

    public void setColumnName(String columnName) {
        this.columnName = columnName;
    }

    public String getReferenceTable() {
        return referenceTable;
    }

    public void setReferenceTable(String referenceTable) {
        this.referenceTable = referenceTable;
    }

    public String getReferenceColumn() {
        return referenceColumn;
    }

    public void setReferenceColumn(String referenceColumn) {
        this.referenceColumn = referenceColumn;
    }

}


package Model;

import java.util.ArrayList;
import java.util.HashMap;


public class Database {
	String name;
	public HashMap<String, Table> tables;
	
	public Database(String name) {
		this.name=name;
		this.tables=new HashMap<String, Table>();
	}
	
	public String getDabaseName() {
		return name;
	}

	public ArrayList<String> getTables(){
		ArrayList<String> tableName=new ArrayList<>();
		for (String key : tables.keySet()) {
            tableName.add(key);
        }
		return tableName;
	}
}


package Model;

import java.util.*;

public class Row {
    private Map<String, Object> data;

    public Row() {
        this.data = new HashMap<>();
    }

    public void setColumnValue(String columnName, Object value) {
        data.put(columnName, value);
    }

    public Object getColumnValue(String columnName) {
        return data.get(columnName);
    }

    public Map<String, Object> getData() {
        return data;
    }
}



package Model;

import java.util.ArrayList;
import java.util.List;

public class Table {
    private String name;
    private List<Column> columns;
    private List<Row> rows;

    public Table(String name, List<Column> columns) {
        this.name = name;
        this.columns = columns;
        this.rows =new ArrayList<>();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<Column> getColumns() {
        return columns;
    }

    public void setColumns(List<Column> columns) {
        this.columns = columns;
    }

    public List<Row> getRows() {
        return rows;
    }

    public void setRows(List<Row> rows) {
        this.rows = rows;
    }
    
    @Override
    public String toString() {
        return "Table{name='" + name + "', columns=" + columns + ", rows=" + rows +"}";
    }
}



package Model;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class User {
	String userId;
	String username;
	String password;
	String email;
	Date dateOfBirth;
	String sessionId;
	public HashMap<String, Database> databases;
	String HomeDirectory;

	// Constructor
	public User(String username, String password, String email, Date dateOfBirth) {
		this.username = username;
		this.password = password;
		this.email = email;
		this.dateOfBirth = dateOfBirth;
		this.sessionId = "";
		this.HomeDirectory="/home/sabari-zstk369/Damaal/"+userId;
		databases=new HashMap<String, Database>();
	}

	public String getUserId() {
		return userId;
	}

	public void setUserId(String userId) {
		this.userId = userId;
	}

	public ArrayList<String> getDatabases() {
		ArrayList<String> databaseName=new ArrayList<>();
		for (String key : databases.keySet()) {
			databaseName.add(key);
        }
		return databaseName;
	}
	
	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getSessionId() {
		return sessionId;
	}

	public void setSessionId(String sessionId) {
		this.sessionId = sessionId;
	}
	

	public String getHomeDirectory() {
		return HomeDirectory;
	}

	public void setHomeDirectory(String homeDirectory) {
		HomeDirectory = homeDirectory;
	}

	// Authentication Methods
	public boolean login(String username, String password) {
		return this.username.equals(username) && this.password.equals(password);
	}

	public void logout() {
		this.sessionId = "";
		System.out.println(username + " logged out.");
	}
}






controller---------

package Controller;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.List;

import Model.*;

public class DatabaseOperation {

	User user;

	DatabaseOperation(User user) {
		this.user = user;
	}

	boolean createDatabase(Database db) {

		String path = "/home/sabari-zstk369/Damaal/" + user.getUserId() + "/" + db.getDabaseName();

		File folder = new File(path);

		if (folder.exists()) {
			System.out.println("Hello");
			return false;
		} else {
			if (folder.mkdirs()) {
				System.out.println("HII");
				user.databases.put(db.getDabaseName(), db);
				return true;
			}
		}
		return false;
	}

	static boolean deleteFolder(String folderPath) throws IOException {
		Path folder = Paths.get(folderPath);
		if (Files.exists(folder)) {
			Files.walk(folder).sorted((a, b) -> b.compareTo(a)).forEach(path -> {
				try {
					Files.delete(path);
				} catch (IOException e) {
//                         throw new RuntimeException("Failed to delete: " + path, e);
					////////////
				}
			});
			return true;
		}
		return false;

	}

	boolean dropDatabase(String dbName) {
		for (String db : user.getDatabases()) {
			if (db.equals(dbName)) {
				try {
					deleteFolder("/home/sabari-zstk369/Damaal/" + dbName);
				} catch (Exception e) {
					return false;
				}
				user.getDatabases().remove(db);
			}
		}
		return false;
	}

	private static void writeMetaData(ByteBuffer buffer, String value) {
		byte[] stringBytes = value.getBytes(StandardCharsets.UTF_8);
		buffer.putInt(stringBytes.length);
		buffer.put(stringBytes);
	}

	public boolean createTable(String databaseName, String tableName, List<Column> columns) {
		Database database = user.databases.get(databaseName);
		System.out.println(database);
		if (database == null) {
//			System.out.println("Database does not exist: " + databaseName);
			return false;
		}

		if (database.getTables().contains(tableName)) {
//			System.out.println("Table already exists: " + tableName);
			return false;
		}

		Table newTable = new Table(tableName, columns);

		database.tables.put(tableName, newTable);

		String tableFolderPath = user.getHomeDirectory() + "/" + database.getDabaseName() + "/" + tableName;

		File tableFolder = new File(tableFolderPath);

		if (!tableFolder.exists() && tableFolder.mkdir()) {
			try (FileChannel channel = FileChannel.open(Paths.get(tableFolderPath + "/Metadata"),
					StandardOpenOption.CREATE, StandardOpenOption.APPEND)) {

				ByteBuffer buffer = ByteBuffer.allocate(1024);

				for (Column c : columns) {
					Path filePath = Paths.get(tableFolderPath+"/"+c.getName()); 
			        try {
			            Files.createFile(filePath);
			            System.out.println("File created: " + filePath);
			        } catch (FileAlreadyExistsException e) {
			            System.out.println("File already exists.");
			        } catch (Exception e) {
			            e.printStackTrace();
			        }
					
					writeMetaData(buffer, c.getName()); // Writing column name
					writeMetaData(buffer, c.getDataType()); // Writing column data type

					// Serialize Constraint object
					try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
							ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream)) {

						objectOutputStream.writeObject(c.getConstraint());
						objectOutputStream.flush();

						// Convert the byte array to ByteBuffer
						byte[] constraintBytes = byteArrayOutputStream.toByteArray();
						ByteBuffer constraintBuffer = ByteBuffer.wrap(constraintBytes);

						// Write serialized constraint data
						if (buffer.remaining() < constraintBuffer.remaining()) {
							buffer.flip();
							channel.write(buffer);
							buffer.clear();
						}
						buffer.putInt(constraintBytes.length);
						buffer.put(constraintBuffer);

					} catch (IOException e) {
//	 	                System.out.println("Error serializing constraint: " + e.getMessage());
					}
				}

				buffer.flip();
				while (buffer.hasRemaining()) {
					channel.write(buffer);
				}
				buffer.clear();
				return true;

			} catch (IOException e) {
//	 	        System.out.println("Error writing metadata: " + e.getMessage());
				return false;
			}
		}
		return false;
	}
	
	public boolean dropTable(String databaseName, String tableName) {
		Database database = user.databases.get(databaseName);
		if (database == null) {
//			System.out.println("Database does not exist: " + databaseName);
			return false;
		}

		if (database.getTables().contains(tableName)) {
//			System.out.println("Table already exists: " + tableName);
			return false;
		}

		
		return false;
	}
	
	
}




//update database operation

package Controller;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.List;

import Model.*;

public class DatabaseOperation {

	User user;

	DatabaseOperation(User user) {
		this.user = user;
	}

	boolean createDatabase(Database db) {

		String path = "/home/sabari-zstk369/Damaal/" + user.getUserId() + "/" + db.getDabaseName();

		File folder = new File(path);

		if (folder.exists()) {
			System.out.println("Hello");
			return false;
		} else {
			if (folder.mkdirs()) {
				System.out.println("HII");
				user.databases.put(db.getDabaseName(), db);
				return true;
			}
		}
		return false;
	}

	static boolean deleteFolder(String folderPath) throws IOException {
		Path folder = Paths.get(folderPath);
		if (Files.exists(folder)) {
			Files.walk(folder).sorted((a, b) -> b.compareTo(a)).forEach(path -> {
				try {
					Files.delete(path);
				} catch (IOException e) {
//                         throw new RuntimeException("Failed to delete: " + path, e);
					////////////
				}
			});
			return true;
		}
		return false;

	}

	boolean dropDatabase(String dbName) {
		for (String db : user.getDatabases()) {
			if (db.equals(dbName)) {
				try {
					deleteFolder("/home/sabari-zstk369/Damaal/" + dbName);
				} catch (Exception e) {
					return false;
				}
				user.getDatabases().remove(db);
			}
		}
		return false;
	}

	private static void writeMetaData(ByteBuffer buffer, String value) {
		byte[] stringBytes = value.getBytes(StandardCharsets.UTF_8);
		buffer.putInt(stringBytes.length);
		buffer.put(stringBytes);
	}

	public boolean createTable(String databaseName, String tableName, List<Column> columns) {
		Database database = user.databases.get(databaseName);
		System.out.println(database);
		if (database == null) {
//			System.out.println("Database does not exist: " + databaseName);
			return false;
		}

		if (database.getTables().contains(tableName)) {
//			System.out.println("Table already exists: " + tableName);
			return false;
		}

		Table newTable = new Table(tableName, columns);

		database.tables.put(tableName, newTable);

		String tableFolderPath = user.getHomeDirectory() + "/" + database.getDabaseName() + "/" + tableName;

		File tableFolder = new File(tableFolderPath);

		if (!tableFolder.exists() && tableFolder.mkdir()) {
			try (FileChannel channel = FileChannel.open(Paths.get(tableFolderPath + "/Metadata"),
					StandardOpenOption.CREATE, StandardOpenOption.APPEND)) {

				ByteBuffer buffer = ByteBuffer.allocate(1024);

				for (Column c : columns) {
					Path filePath = Paths.get(tableFolderPath+"/"+c.getName()); 
			        try {
			            Files.createFile(filePath);
			        } catch (FileAlreadyExistsException e) {
			            System.out.println("File already exists.");
			        } catch (Exception e) {
			            e.printStackTrace();
			        }
					
					writeMetaData(buffer, c.getName()); // Writing column name
					writeMetaData(buffer, c.getDataType()); // Writing column data type
					if(c.getDataType().equals("String")) {
						try {
							Path metaFilePath = Paths.get(tableFolderPath+"/"+c.getName()+"_metadata"); 
				            Files.createFile(metaFilePath);
				        } catch (FileAlreadyExistsException e) {
				            System.out.println("File already exists.");
				        } catch (Exception e) {
				            e.printStackTrace();
				        }
					}

					// Serialize Constraint object
					try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
							ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream)) {

						objectOutputStream.writeObject(c.getConstraint());
						objectOutputStream.flush();

						// Convert the byte array to ByteBuffer
						byte[] constraintBytes = byteArrayOutputStream.toByteArray();
						ByteBuffer constraintBuffer = ByteBuffer.wrap(constraintBytes);

						// Write serialized constraint data
						if (buffer.remaining() < constraintBuffer.remaining()) {
							buffer.flip();
							channel.write(buffer);
							buffer.clear();
						}
						buffer.putInt(constraintBytes.length);
						buffer.put(constraintBuffer);

					} catch (IOException e) {
//	 	                System.out.println("Error serializing constraint: " + e.getMessage());
					}
				}

				buffer.flip();
				while (buffer.hasRemaining()) {
					channel.write(buffer);
				}
				buffer.clear();
				return true;

			} catch (IOException e) {
//	 	        System.out.println("Error writing metadata: " + e.getMessage());
				return false;
			}
		}
		return false;
	}
	
	public boolean dropTable(String databaseName, String tableName) {
		Database database = user.databases.get(databaseName);
		if (database == null) {
//			System.out.println("Database does not exist: " + databaseName);
			return false;
		}

		if (database.getTables().contains(tableName)) {
//			System.out.println("Table already exists: " + tableName);
			return false;
		}

		
		return false;
	}
	
	
	
}

public class ColumnDAO {

    private static  int initialCapacity =1024;
    private  static final int boolean_BYTES=1;
     public static void insertValue(String fileName,String MetaFileName, String datatype, String constraint, Object value)
    {
    	
    	 if(!checkColumnDatatype(MetaFileName,fileName,datatype))
    	 {
    		 System.out.println("incorrect datatype");
    	 }
    	 
        ByteBuffer buffer = ByteBuffer.allocate(initialCapacity);
        
        ByteBuffer valueBuffer = prepareValueBuffer(fileName, value);
        
        if (buffer.remaining() < valueBuffer.remaining()) {
        	System.out.println("buffer remaining " +buffer.remaining());
        	System.out.println("value Buffer remaining "+valueBuffer.remaining());
        	
            buffer = resizeBuffer(buffer, buffer.capacity() * 2);
        }
        buffer.put(valueBuffer);
        FileCreation(fileName, buffer);
    }

     
    private static ByteBuffer prepareValueBuffer(String fileName, Object value) {

        ByteBuffer valueBuffer=ByteBuffer.allocate(initialCapacity);
    	if (value instanceof String) {
         	
        	System.out.println("String value consider");
        	
        	StringDescription(fileName,(String)value);
           byte[] stringBytes = ((String) value).getBytes(StandardCharsets.UTF_8);
            valueBuffer = ByteBuffer.allocate(stringBytes.length);         
            valueBuffer.put(stringBytes);  
            valueBuffer.flip();
      	  return valueBuffer;     
        }
        long rowid=getRowId(fileName);
        boolean isDeleted=false;
        if (value instanceof Integer) {
            valueBuffer = ByteBuffer.allocate(Long.BYTES+boolean_BYTES+Integer.BYTES);
            valueBuffer.putLong(rowid+1);
            valueBuffer.put((byte)(isDeleted?1:0));
            valueBuffer.putInt((Integer)value);
        } else if (value instanceof Long) {
            valueBuffer = ByteBuffer.allocate(Long.BYTES+boolean_BYTES+Long.BYTES);
            valueBuffer.putLong(rowid+1);
            valueBuffer.put((byte)(isDeleted?1:0));
            valueBuffer.putLong((Long) value);
        } else if (value instanceof Float) {
            valueBuffer = ByteBuffer.allocate(Long.BYTES+boolean_BYTES+Float.BYTES);
            valueBuffer.putLong(rowid+1);
            valueBuffer.put((byte)(isDeleted?1:0));
            valueBuffer.putFloat((Float) value);
        } else if (value instanceof Double) {
            valueBuffer = ByteBuffer.allocate(Long.BYTES+boolean_BYTES+Double.BYTES);
            valueBuffer.putLong(rowid+1);
            valueBuffer.put((byte)(isDeleted?1:0));
            valueBuffer.putDouble((Double) value);
        } else if (value instanceof Short) {
            valueBuffer = ByteBuffer.allocate(Long.BYTES+boolean_BYTES+Short.BYTES);
            valueBuffer.putLong(rowid+1);
            valueBuffer.put((byte)(isDeleted?1:0));
            valueBuffer.putShort((Short) value);
        } else if (value instanceof Byte) {
            valueBuffer = ByteBuffer.allocate(Long.BYTES+boolean_BYTES+Byte.BYTES);
            valueBuffer.putLong(rowid+1);
            valueBuffer.put((byte)(isDeleted?1:0));
            valueBuffer.put((Byte) value);
        }  else {
            throw new IllegalArgumentException("Unsupported data type: " + value.getClass());
        }

        valueBuffer.flip();
    	  return valueBuffer;   
    }

    
    //check the datatype of the given column is correct or not
    
    public static boolean checkColumnDatatype(String metaDataFileName,String fileName ,String datatype)
    {
    	List<Column> columnsArray=readMetadata(metaDataFileName);
    	for(Column column:columnsArray)
    	{
    		if((fileName.equals(column.getName())) && (datatype.equals(column.getDataType())))
    		{
    		   return true;	
    		}
    	}
    	
    	return false;
    	
    	
    }
    
    
    // string file with full information
    public static void  StringDescription(String fileName,String data)
    {
    	ByteBuffer buffer=ByteBuffer.allocate(initialCapacity);
      	try(FileChannel channel=FileChannel.open(Path.of(fileName +"description"), StandardOpenOption.CREATE,StandardOpenOption.APPEND))
      	{

      		System.out.println("check1");
         long[] rowAndOffset=RowIAndOffset(fileName +"description");
          long rowId=rowAndOffset[0];
          long offset=rowAndOffset[1];  
          long length=rowAndOffset[2];
          
          System.out.println("OutOffset  "+offset);
//          System.out.println("rowid "+rowId);
          
          boolean isDeleted=false;
       

    	    buffer.flip();
    	    buffer=buffer.allocate(Long.BYTES+boolean_BYTES+Integer.BYTES+Long.BYTES);
    	    buffer.putLong(rowId+1);
    	    buffer.put((byte)(isDeleted?1:0));  
    	    buffer.putLong(offset+length);
    	    int dataLength=data.length();
    	    buffer.putInt(dataLength);
    	    buffer.flip();

            // Write the buffer content to the file
            channel.write(buffer);
            buffer.clear();  // C
      	}
    	  	catch(IOException e)
    		{
    	  		
    			System.out.println("Print stack error");
    	        e.printStackTrace();   
    	      }
    	  	

    }
    
    // writing for row and offset value
    
    public static long[] RowIAndOffset(String fileName)
    {
    	long rowid=0;
    	long offset=0;
    	int length=0;
    	ByteBuffer buffer=ByteBuffer.allocate(initialCapacity);
    	long[] rowAndOffset=new long[3];

    	System.out.println("fileName " +fileName);
  
    	try(FileChannel channel=FileChannel.open(Path.of(fileName),StandardOpenOption.READ))
    	{
//    		System.out.println("hello");
    		while(channel.read(buffer)>0)
    		{
    			buffer.flip();
    			while(buffer.remaining()>=21)
    			{
    				rowid=buffer.getLong();
    				boolean isDeleted=buffer.get()!=0;
    				offset=buffer.getLong();
    			   length=buffer.getInt();
    			
    				System.out.println("row" +rowid);  
    			    System.out.println("isDeleted "+isDeleted);
    				System.out.println("offset "+offset);
    				System.out.println("length "+length);
    				
    				rowAndOffset[0]=rowid;
    				rowAndOffset[1]=offset;		
    				rowAndOffset[2]=length;
    			}
    		}
    		
    	}
    	catch(IOException e)
    	{
     		System.out.println("check2");
    		System.out.println(e.getMessage());
    	}
    	rowAndOffset[0]=rowid;
    	rowAndOffset[1]=offset;
    	return rowAndOffset;
       

    }

    public static void ValueWithInteger(String fileName, String value)
    {
        ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES);
        try(FileChannel channel = FileChannel.open(Path.of(fileName + "withLength"), StandardOpenOption.CREATE, StandardOpenOption.APPEND)) {
            buffer.putInt(value.length());
            buffer.flip();
            channel.write(buffer);
            buffer.clear();
        } catch (IOException e) {
            e.printStackTrace();        }
    }

    private static ByteBuffer resizeBuffer(ByteBuffer buffer, int newSize) {
        ByteBuffer newBuffer = ByteBuffer.allocate(newSize);
        buffer.flip();
        newBuffer.put(buffer);
        return newBuffer;
    }

    public static void FileCreation(String filename, ByteBuffer buffer) {
        try (FileChannel channel = FileChannel.open(Path.of(filename), StandardOpenOption.APPEND)) {
            buffer.flip();
            channel.write(buffer);
            buffer.clear();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    

    public static long  getRowId(String fileName) {
    	long rowid=0;
    	 try (FileChannel channel = FileChannel.open(Path.of(fileName), StandardOpenOption.READ)) {
             ByteBuffer buffer = ByteBuffer.allocate(1024); 

             while (channel.read(buffer) > 0) { 
                 buffer.flip();  

                 while (buffer.remaining() >= 13) {  
                     rowid = buffer.getLong(); 
                     boolean booleanValue = buffer.get() != 0;  
                     int value = buffer.getInt();  
                      System.out.println("Row ID: " + rowid);
                     System.out.println("Deleted: " + booleanValue);
                     System.out.println("Value: " + value);
                 }
                 buffer.clear();  

         } }catch (IOException e) {
             e.printStackTrace(); 
         }

        return rowid;
    }
    public static List<Column> readMetadata(String filePath) {
        List<Column> columns = new ArrayList<>();
        try (FileChannel channel = FileChannel.open(Paths.get(filePath), StandardOpenOption.READ)) {
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            channel.read(buffer);
            buffer.flip();


            while (buffer.hasRemaining()) {
                // Read column name
                String columnName = readString(buffer);

                // Read data type
                String dataType = readString(buffer);

                // Read constraint object
                Object constraint = readObject(buffer);

                // Reconstruct Column object
                Column column = new Column(columnName, dataType,false, (Constraint)constraint);
                columns.add(column);
            }

            // Print Columns
            for (Column column : columns) {
                System.out.println("Column: " + column.getName() + ", Type: " + column.getDataType() +
                        ", Constraint: " + column.getConstraint());
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
        return columns;
    }

    private static String readString(ByteBuffer buffer) {
        int length = buffer.getInt(); // Read string length
        byte[] bytes = new byte[length];
        buffer.get(bytes); // Read actual string data
        return new String(bytes);
    }

    private static Object readObject(ByteBuffer buffer) {
        int length = buffer.getInt(); // Read object size
        byte[] bytes = new byte[length];
        buffer.get(bytes); // Read object data

        try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes))) {
            return ois.readObject(); 
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }
    



